{"config":{"lang":["pt"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Documenta\u00e7\u00e3o TypeScript","text":"<p>Bem-vindo \u00e0 Documenta\u00e7\u00e3o TypeScript! Aqui voc\u00ea encontrar\u00e1 uma explica\u00e7\u00e3o abrangente sobre TypeScript, uma linguagem que combina a flexibilidade do JavaScript com a seguran\u00e7a da tipagem est\u00e1tica.</p>"},{"location":"#o-que-voce-vai-encontrar-aqui","title":"O que Voc\u00ea Vai Encontrar Aqui","text":"<p>Esta documenta\u00e7\u00e3o est\u00e1 organizada para ajudar tanto iniciantes quanto desenvolvedores experientes a entender e utilizar o TypeScript de maneira eficaz. Aqui est\u00e3o os principais t\u00f3picos que abordamos:</p>"},{"location":"#1-introducao-ao-typescript","title":"1. Introdu\u00e7\u00e3o ao TypeScript","text":"<ul> <li>O que \u00e9 TypeScript e por que ele \u00e9 uma escolha poderosa para projetos de todos os tamanhos.</li> <li>Exemplos pr\u00e1ticos que demonstram as vantagens de usar TypeScript em compara\u00e7\u00e3o ao JavaScript.</li> </ul>"},{"location":"#2-fundamentos","title":"2. Fundamentos","text":"<ul> <li>Uma vis\u00e3o detalhada dos tipos b\u00e1sicos, como <code>number</code>, <code>string</code>, <code>boolean</code>, e tipos complexos como <code>arrays</code>, <code>tuplas</code>, e <code>enums</code>.</li> <li>Como declarar e utilizar fun\u00e7\u00f5es de forma eficiente, aproveitando a tipagem est\u00e1tica para prevenir erros comuns.</li> </ul>"},{"location":"#3-programacao-orientada-a-objetos-com-typescript","title":"3. Programa\u00e7\u00e3o Orientada a Objetos com TypeScript","text":"<ul> <li>Como definir classes e aplicar os conceitos de heran\u00e7a e encapsulamento.</li> <li>Utiliza\u00e7\u00e3o de modificadores de acesso (<code>public</code>, <code>private</code>, <code>protected</code>) para controlar a visibilidade dos membros da classe.</li> </ul>"},{"location":"#4-conceitos-avancados","title":"4. Conceitos Avan\u00e7ados","text":"<ul> <li>Uma introdu\u00e7\u00e3o aos <code>Generics</code>, que permitem a cria\u00e7\u00e3o de componentes reutiliz\u00e1veis e flex\u00edveis.</li> <li>Como utilizar <code>Decorators</code> para adicionar funcionalidades extras a classes e m\u00e9todos.</li> </ul>"},{"location":"#5-integracoes-com-ferramentas-modernas","title":"5. Integra\u00e7\u00f5es com Ferramentas Modernas","text":"<ul> <li>Uso de TypeScript com frameworks populares como React e Node.js.</li> <li>Configura\u00e7\u00e3o de um ambiente de desenvolvimento que aproveite ao m\u00e1ximo as ferramentas de build e integra\u00e7\u00f5es.</li> </ul>"},{"location":"#6-praticas-recomendadas","title":"6. Pr\u00e1ticas Recomendadas","text":"<ul> <li>Dicas para escrever c\u00f3digo TypeScript limpo, organizado e f\u00e1cil de manter.</li> <li>Estrat\u00e9gias para evitar armadilhas comuns e melhorar a qualidade do seu c\u00f3digo.</li> </ul>"},{"location":"#comece-agora","title":"Comece Agora!","text":"<p>Se voc\u00ea \u00e9 novo no TypeScript, recomendamos come\u00e7ar com a Introdu\u00e7\u00e3o, onde explicamos os conceitos fundamentais e mostramos como configurar seu ambiente. Se voc\u00ea j\u00e1 tem experi\u00eancia com TypeScript, sinta-se \u00e0 vontade para explorar os t\u00f3picos avan\u00e7ados que mais interessam a voc\u00ea.</p> <p>Aproveite a documenta\u00e7\u00e3o e bons estudos!</p>"},{"location":"introducao/","title":"Introdu\u00e7\u00e3o ao TypeScript","text":""},{"location":"introducao/#o-que-e-typescript","title":"O que \u00e9 TypeScript?","text":"<p>TypeScript \u00e9 um superconjunto tipado de JavaScript que compila para JavaScript puro. Ele adiciona tipagem est\u00e1tica e outros recursos, como interfaces e enumera\u00e7\u00f5es, que ajudam a prevenir erros comuns em tempo de desenvolvimento.</p>"},{"location":"introducao/#por-que-usar-typescript","title":"Por que usar TypeScript?","text":""},{"location":"introducao/#1-seguranca-de-tipos","title":"1. Seguran\u00e7a de Tipos","text":"<p>Em JavaScript, voc\u00ea pode facilmente cometer erros de tipo que s\u00f3 ser\u00e3o descobertos em tempo de execu\u00e7\u00e3o. Por exemplo:</p> <pre><code>function soma(a, b) {\n    return a + b;\n}\n\nconsole.log(soma(5, \"10\")); // Resultado: \"510\" (string)\n</code></pre> <p>Em TypeScript, voc\u00ea pode evitar esse tipo de erro especificando os tipos de entrada:</p> <p><pre><code>function soma(a: number, b: number): number {\n    return a + b;\n}\n\n// console.log(soma(5, \"10\")); // Erro: Argumento de tipo 'string' n\u00e3o \u00e9 atribu\u00edvel ao par\u00e2metro de tipo 'number'.\n</code></pre> 2. Melhor Autocompletar e Refatora\u00e7\u00e3o  TypeScript melhora significativamente a experi\u00eancia do desenvolvedor ao trabalhar com editores de c\u00f3digo, oferecendo autocompletar inteligente e verifica\u00e7\u00e3o de tipos. Isso \u00e9 especialmente \u00fatil em grandes bases de c\u00f3digo. Exemplo Pr\u00e1tico:  Com JavaScript:</p> <pre><code>let usuario = { nome: \"Nalberth\", idade: 30 };\nconsole.log(usuario.nome);\n</code></pre> <p>Se voc\u00ea errar o nome da propriedade, o erro s\u00f3 aparecer\u00e1 em tempo de execu\u00e7\u00e3o:</p> <pre><code>console.log(usuario.nomes); // undefined\n</code></pre> <p>Com TypeScript:</p> <p><pre><code>interface Usuario {\n    nome: string;\n    idade: number;\n}\n\nlet usuario: Usuario = { nome: \"Nalberth\", idade: 30 };\nconsole.log(usuario.nome);\n\n// console.log(usuario.nomes); // Erro: A propriedade 'nomes' n\u00e3o existe no tipo 'Usuario'.\n</code></pre> 3. Detec\u00e7\u00e3o Precoce de Erros  TypeScript permite que voc\u00ea identifique erros antes mesmo de executar o c\u00f3digo, economizando tempo e evitando bugs em produ\u00e7\u00e3o. Exemplo Pr\u00e1tico:  Em JavaScript, voc\u00ea pode acidentalmente passar um n\u00famero onde se espera uma string:</p> <pre><code>function boasVindas(nome) {\n    return \"Bem-vindo, \" + nome;\n}\n\nboasVindas(123); // \"Bem-vindo, 123\"\n</code></pre> <p>Em TypeScript, isso geraria um erro de compila\u00e7\u00e3o, evitando comportamentos inesperados:</p> <p><pre><code>function boasVindas(nome: string): string {\n    return \"Bem-vindo, \" + nome;\n}\n\n// boasVindas(123); // Erro: Argumento de tipo 'number' n\u00e3o \u00e9 atribu\u00edvel ao par\u00e2metro de tipo 'string'.\n</code></pre> 4. Melhor Suporte para Ferramentas de Build e Integra\u00e7\u00e3o  TypeScript se integra bem com diversas ferramentas de build modernas, como Webpack e Babel, facilitando a configura\u00e7\u00e3o e o gerenciamento de projetos complexos. Exemplo Pr\u00e1tico:  Usando TypeScript com React permite detectar erros de tipo em componentes, melhorando a confiabilidade da aplica\u00e7\u00e3o:</p> <pre><code>interface Props {\n    nome: string;\n}\n\nconst BoasVindas: React.FC&lt;Props&gt; = ({ nome }) =&gt; {\n    return &lt;h1&gt;Bem-vindo, {nome}!&lt;/h1&gt;;\n};\n\n// &lt;BoasVindas nome={123} /&gt; // Erro: 'number' n\u00e3o \u00e9 atribu\u00edvel a 'string'.\n</code></pre>"},{"location":"introducao/#instalacao-e-configuracao","title":"Instala\u00e7\u00e3o e Configura\u00e7\u00e3o","text":"<p>Voc\u00ea pode instalar o TypeScript globalmente usando npm:</p> <p><pre><code>npm install -g typescript\n</code></pre> Para come\u00e7ar um novo projeto TypeScript, crie um arquivo <code>tsconfig.json</code> que configurar\u00e1 o compilador:</p> <pre><code>{\n  \"compilerOptions\": {\n    \"target\": \"es5\",\n    \"module\": \"commonjs\",\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"skipLibCheck\": true\n  }\n}\n</code></pre> <p>Isso configura o TypeScript para compilar o c\u00f3digo em um formato compat\u00edvel com a maioria dos navegadores e ambientes de execu\u00e7\u00e3o, enquanto aplica regras rigorosas de tipagem.</p>"},{"location":"praticas-recomendadas/","title":"Pr\u00e1ticas Recomendadas em TypeScript","text":"<p>TypeScript \u00e9 uma ferramenta poderosa que, quando usada corretamente, pode melhorar significativamente a qualidade do c\u00f3digo. Esta se\u00e7\u00e3o cobre as pr\u00e1ticas recomendadas para escrever c\u00f3digo TypeScript robusto, claro e sustent\u00e1vel, garantindo que voc\u00ea aproveite ao m\u00e1ximo as capacidades da linguagem.</p>"},{"location":"praticas-recomendadas/#1-use-tipos-estritos","title":"1. Use Tipos Estritos","text":"<p>Uma das maiores vantagens do TypeScript \u00e9 a tipagem est\u00e1tica, que ajuda a evitar erros de tipo em tempo de execu\u00e7\u00e3o. Ative as op\u00e7\u00f5es de tipagem estrita (<code>strict</code>) no <code>tsconfig.json</code> para garantir que o compilador aplique as regras mais rigorosas.</p> <p>Exemplo de Configura\u00e7\u00e3o:</p> <pre><code>{\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"noImplicitAny\": true,\n    \"strictNullChecks\": true,\n    \"strictFunctionTypes\": true,\n    \"strictBindCallApply\": true,\n    \"alwaysStrict\": true,\n    \"strictPropertyInitialization\": true\n  }\n}\n</code></pre> <p>Essas op\u00e7\u00f5es for\u00e7am voc\u00ea a ser expl\u00edcito sobre os tipos e reduzem a probabilidade de erros. 2. Prefira Interfaces para Objetos  Embora o TypeScript permita a cria\u00e7\u00e3o de tipos e interfaces para definir a forma de objetos, geralmente \u00e9 prefer\u00edvel usar interfaces, pois elas s\u00e3o mais flex\u00edveis e extens\u00edveis. Exemplo: </p> <pre><code>interface Usuario {\n    nome: string;\n    idade: number;\n    email?: string; // Propriedade opcional\n}\n\nconst usuario: Usuario = {\n    nome: \"Nalberth\",\n    idade: 30\n};\n</code></pre> <p>Interfaces s\u00e3o mais adequadas para modelar dados complexos e permitem a extens\u00e3o com facilidade. 3. Evite o Tipo <code>any</code> O tipo <code>any</code> desabilita a verifica\u00e7\u00e3o de tipo para uma vari\u00e1vel, o que vai contra o prop\u00f3sito de usar TypeScript. Sempre que poss\u00edvel, evite <code>any</code> e opte por tipos mais espec\u00edficos ou use uni\u00e3o de tipos.Exemplo Problem\u00e1tico:** </p> <p><pre><code>let dados: any;\ndados = 123;\ndados = \"Texto\";\ndados = true; // Compila, mas perde a seguran\u00e7a de tipo\n</code></pre> Solu\u00e7\u00e3o: </p> <p><pre><code>let dados: number | string | boolean;\ndados = 123;\ndados = \"Texto\";\ndados = true; // Agora, o tipo \u00e9 restrito a `number`, `string` ou `boolean`\n</code></pre> 4. Mantenha o C\u00f3digo Organizado com M\u00f3dulos  Organize seu c\u00f3digo em m\u00f3dulos e namespaces para melhorar a modularidade e facilitar a manuten\u00e7\u00e3o. Utilize o sistema de m\u00f3dulos do ES6 ou CommonJS, dependendo do ambiente de execu\u00e7\u00e3o. Exemplo de M\u00f3dulos: </p> <pre><code>// mathUtils.ts\nexport function somar(a: number, b: number): number {\n    return a + b;\n}\n\n// app.ts\nimport { somar } from './mathUtils';\n\nconsole.log(somar(10, 20));\n</code></pre> <p>Isso mant\u00e9m o c\u00f3digo organizado e facilita a reutiliza\u00e7\u00e3o de fun\u00e7\u00f5es em diferentes partes do projeto. 5. Utilize Enum para Conjuntos de Valores Finitos Quando voc\u00ea tem um conjunto fixo de valores que uma vari\u00e1vel pode assumir, use <code>enum</code> para aumentar a legibilidade e a seguran\u00e7a.Exemplo: </p> <pre><code>enum Cor {\n    Vermelho,\n    Verde,\n    Azul\n}\n\nlet corFavorita: Cor = Cor.Verde;\n</code></pre> <p>Enums s\u00e3o particularmente \u00fateis para representar estados, cores, op\u00e7\u00f5es de configura\u00e7\u00e3o, e outras cole\u00e7\u00f5es de valores fixos. 6. Documente Seu C\u00f3digo com JSDoc  Mesmo com a tipagem est\u00e1tica, \u00e9 importante documentar suas fun\u00e7\u00f5es, classes e interfaces. O JSDoc \u00e9 suportado pelo TypeScript e melhora a autocompletar, al\u00e9m de servir como uma refer\u00eancia r\u00e1pida para outros desenvolvedores. Exemplo: </p> <pre><code>/**\n * Soma dois n\u00fameros.\n * @param a - O primeiro n\u00famero.\n * @param b - O segundo n\u00famero.\n * @returns A soma de `a` e `b`.\n */\nfunction somar(a: number, b: number): number {\n    return a + b;\n}\n</code></pre> <p>Essa documenta\u00e7\u00e3o ajuda a entender rapidamente o prop\u00f3sito e o uso de uma fun\u00e7\u00e3o ou classe. 7. Utilize <code>readonly</code> e <code>const</code> Quando Poss\u00edvel Utilize <code>readonly</code> para propriedades de classes que n\u00e3o devem ser alteradas ap\u00f3s a inicializa\u00e7\u00e3o, e <code>const</code> para vari\u00e1veis que n\u00e3o devem ser reatribu\u00eddas.Exemplo:** </p> <pre><code>class Usuario {\n    readonly id: number;\n    nome: string;\n\n    constructor(id: number, nome: string) {\n        this.id = id;\n        this.nome = nome;\n    }\n}\n\nconst usuario: Usuario = new Usuario(1, \"Nalberth\");\n// usuario.id = 2; // Erro: id \u00e9 somente leitura\n</code></pre> <p>Isso protege contra modifica\u00e7\u00f5es acidentais e torna a inten\u00e7\u00e3o do c\u00f3digo mais clara. 8. Evite Excessos de Union Types Embora <code>union types</code> sejam \u00fateis, evit\u00e1-los em excesso pode tornar o c\u00f3digo dif\u00edcil de entender e manter. Se voc\u00ea perceber que est\u00e1 usando muitos <code>union types</code>, considere reavaliar o design do c\u00f3digo.Exemplo: </p> <pre><code>type Id = string | number | null | undefined;\n</code></pre> <p>Esse tipo de defini\u00e7\u00e3o pode indicar que o design pode ser simplificado ou que uma abordagem diferente (como interfaces mais restritas) seria mais adequada. 9. Prefira Fun\u00e7\u00f5es Puramente Tipadas Esforce-se para que suas fun\u00e7\u00f5es sejam puramente tipadas, evitando <code>any</code>, e que retornem tipos claros e previs\u00edveis. Isso melhora a previsibilidade e a seguran\u00e7a do c\u00f3digo.Exemplo: </p> <pre><code>function processarDados(dados: string[]): string[] {\n    return dados.map(dado =&gt; dado.toUpperCase());\n}\n</code></pre> <p>Aqui, a fun\u00e7\u00e3o recebe um array de strings e retorna um array de strings, sem ambiguidade nos tipos. 10. Testes com Tipagem Rigorosa  Ao escrever testes, utilize tipos rigorosos para garantir que os testes tamb\u00e9m estejam corretos e que as suposi\u00e7\u00f5es sobre os tipos de dados sejam verificadas. Exemplo com Jest: </p> <pre><code>test('deve somar dois n\u00fameros', () =&gt; {\n    const resultado: number = somar(2, 3);\n    expect(resultado).toBe(5);\n});\n</code></pre> <p>Essa pr\u00e1tica assegura que at\u00e9 mesmo os testes sejam mantidos dentro das boas pr\u00e1ticas de tipagem.</p>"},{"location":"praticas-recomendadas/#conclusao","title":"Conclus\u00e3o","text":"<p>Seguir essas pr\u00e1ticas recomendadas ajudar\u00e1 voc\u00ea a tirar o m\u00e1ximo proveito do TypeScript, garantindo que seu c\u00f3digo seja mais seguro, leg\u00edvel e f\u00e1cil de manter. \u00c0 medida que voc\u00ea adota essas pr\u00e1ticas, ver\u00e1 uma melhora na qualidade geral de seus projetos TypeScript e na confian\u00e7a com que desenvolve novas funcionalidades.</p>"},{"location":"avancado/classes/","title":"Classes","text":"<p>Em TypeScript, uma classe \u00e9 uma estrutura que permite criar objetos com propriedades e m\u00e9todos associados. As classes encapsulam dados e comportamentos que s\u00e3o comuns a todas as inst\u00e2ncias da classe. Vamos explorar como definir classes, aplicar heran\u00e7a, e utilizar modificadores de acesso para controlar a visibilidade dos membros da classe.</p>"},{"location":"avancado/classes/#definindo-classes","title":"Definindo Classes","text":"<p>Uma classe em TypeScript \u00e9 definida usando a palavra-chave <code>class</code>, seguida pelo nome da classe. Dentro da classe, podemos definir propriedades e m\u00e9todos. O m\u00e9todo <code>constructor</code> \u00e9 especial e \u00e9 chamado automaticamente quando um novo objeto da classe \u00e9 criado.</p> <p><pre><code>class Pessoa {\n    nome: string;\n    idade: number;\n\n    constructor(nome: string, idade: number) {\n        this.nome = nome;\n        this.idade = idade;\n    }\n\n    saudacao(): string {\n        return `Ol\u00e1, meu nome \u00e9 ${this.nome} e eu tenho ${this.idade} anos.`;\n    }\n}\n</code></pre> No exemplo acima, a classe <code>Pessoa</code> possui duas propriedades (<code>nome</code> e <code>idade</code>) e um m\u00e9todo (<code>saudacao</code>). O m\u00e9todo <code>constructor</code> inicializa as propriedades da classe quando um novo objeto \u00e9 criado.</p>"},{"location":"avancado/classes/#heranca","title":"Heran\u00e7a","text":"<p>Heran\u00e7a \u00e9 um conceito fundamental na POO, que permite que uma classe (subclasse) herde as propriedades e m\u00e9todos de outra classe (superclasse). Isso facilita o reaproveitamento de c\u00f3digo e a cria\u00e7\u00e3o de estruturas hier\u00e1rquicas.</p> <p><pre><code>class Estudante extends Pessoa {\n    curso: string;\n\n    constructor(nome: string, idade: number, curso: string) {\n        super(nome, idade);\n        this.curso = curso;\n    }\n\n    saudacao(): string {\n        return `${super.saudacao()} Estou estudando ${this.curso}.`;\n    }\n}\n</code></pre> No exemplo acima, <code>Estudante</code> \u00e9 uma subclasse de <code>Pessoa</code>. A palavra-chave <code>extends</code> \u00e9 usada para indicar que <code>Estudante</code> herda de <code>Pessoa</code>. O m\u00e9todo <code>saudacao</code> da subclasse <code>Estudante</code> chama o m\u00e9todo <code>saudacao</code> da superclasse <code>Pessoa</code> usando <code>super()</code> e adiciona mais informa\u00e7\u00f5es.</p>"},{"location":"avancado/classes/#modificadores-de-acesso","title":"Modificadores de Acesso","text":"<p>Os modificadores de acesso em TypeScript controlam a visibilidade das propriedades e m\u00e9todos de uma classe. Existem tr\u00eas modificadores principais:</p> <ul> <li> <p>public : Acess\u00edvel de qualquer lugar.</p> </li> <li> <p>private : Acess\u00edvel apenas dentro da pr\u00f3pria classe.</p> </li> <li> <p>protected : Acess\u00edvel dentro da classe e em subclasses.</p> </li> </ul> <p><pre><code>class ContaBancaria {\n    private saldo: number;\n\n    constructor(saldoInicial: number) {\n        this.saldo = saldoInicial;\n    }\n\n    public depositar(valor: number): void {\n        this.saldo += valor;\n    }\n\n    public consultarSaldo(): number {\n        return this.saldo;\n    }\n}\n</code></pre> No exemplo acima, a propriedade <code>saldo</code> \u00e9 privada e s\u00f3 pode ser acessada dentro da classe <code>ContaBancaria</code>. Os m\u00e9todos <code>depositar</code> e <code>consultarSaldo</code> s\u00e3o p\u00fablicos e podem ser acessados de fora da classe. Esses conceitos s\u00e3o fundamentais para criar c\u00f3digo modular, reutiliz\u00e1vel e seguro em TypeScript. Entender como e quando usar classes, heran\u00e7a, e modificadores de acesso \u00e9 essencial para qualquer desenvolvedor que queira aproveitar ao m\u00e1ximo a Programa\u00e7\u00e3o Orientada a Objetos.</p>"},{"location":"avancado/decorators/","title":"Decorators","text":"<p>Decorators em TypeScript s\u00e3o uma forma especial de declarar metadados e adicionar comportamentos a classes, m\u00e9todos, propriedades ou par\u00e2metros. Eles permitem modificar ou estender o comportamento de uma classe ou membro da classe de maneira declarativa, facilitando a reutiliza\u00e7\u00e3o de c\u00f3digo e a implementa\u00e7\u00e3o de padr\u00f5es de design como o decorator pattern.</p>"},{"location":"avancado/decorators/#introducao-aos-decorators","title":"Introdu\u00e7\u00e3o aos Decorators","text":"<p>Decorators s\u00e3o fun\u00e7\u00f5es que s\u00e3o aplicadas a classes, m\u00e9todos, acessores, propriedades ou par\u00e2metros no momento da defini\u00e7\u00e3o. Eles s\u00e3o prefixados com <code>@</code> e podem ser aplicados diretamente sobre as declara\u00e7\u00f5es.</p> <p>Exemplo de um Decorator Simples:</p> <p><pre><code>function logClass(constructor: Function) {\n    console.log(`Classe decorada: ${constructor.name}`);\n}\n\n@logClass\nclass Pessoa {\n    nome: string;\n\n    constructor(nome: string) {\n        this.nome = nome;\n    }\n}\n</code></pre> Neste exemplo, o decorator <code>logClass</code> \u00e9 aplicado \u00e0 classe <code>Pessoa</code>. Quando a classe \u00e9 definida, o decorator \u00e9 executado, registrando o nome da classe no console.</p>"},{"location":"avancado/decorators/#tipos-de-decorators","title":"Tipos de Decorators","text":"<ol> <li>Class Decorators  Class decorators s\u00e3o aplicados \u00e0 declara\u00e7\u00e3o de uma classe e recebem o construtor da classe como argumento. Eles podem modificar ou substituir a classe original. Exemplo: </li> </ol> <p><pre><code>function seloDeClasse&lt;T extends { new(...args: any[]): {} }&gt;(constructor: T) {\n    return class extends constructor {\n        selo = \"Classe Decorada\";\n    };\n}\n\n@seloDeClasse\nclass Produto {\n    nome: string;\n\n    constructor(nome: string) {\n        this.nome = nome;\n    }\n}\n\nlet produto = new Produto(\"Livro\");\nconsole.log(produto.selo); // Sa\u00edda: \"Classe Decorada\"\n</code></pre> Aqui, o decorator <code>seloDeClasse</code> adiciona uma nova propriedade <code>selo</code> a todas as inst\u00e2ncias da classe <code>Produto</code>.2. Method Decorators  Method decorators s\u00e3o aplicados a m\u00e9todos de inst\u00e2ncias ou est\u00e1ticos, permitindo que voc\u00ea modifique ou estenda o comportamento do m\u00e9todo. Exemplo: </p> <p><pre><code>function logarMetodo(target: any, propertyName: string, descriptor: PropertyDescriptor) {\n    const metodoOriginal = descriptor.value;\n\n    descriptor.value = function(...args: any[]) {\n        console.log(`M\u00e9todo ${propertyName} chamado com argumentos:`, args);\n        return metodoOriginal.apply(this, args);\n    };\n}\n\nclass Calculadora {\n    @logarMetodo\n    somar(a: number, b: number): number {\n        return a + b;\n    }\n}\n\nconst calc = new Calculadora();\ncalc.somar(2, 3); // Sa\u00edda: \"M\u00e9todo somar chamado com argumentos: [2, 3]\"\n</code></pre> O decorator <code>logarMetodo</code> intercepta a chamada ao m\u00e9todo <code>somar</code> e registra os argumentos antes de executar o m\u00e9todo original.3. Accessor Decorators  Accessor decorators s\u00e3o aplicados a acessores (getters e setters) de propriedades, permitindo modificar como a propriedade \u00e9 acessada ou modificada. Exemplo: </p> <p><pre><code>function bloquearAccessor(target: any, propertyName: string, descriptor: PropertyDescriptor) {\n    descriptor.set = function(value: any) {\n        console.log(`Tentativa de alterar ${propertyName} bloqueada.`);\n    };\n}\n\nclass Conta {\n    private _saldo: number = 0;\n\n    @bloquearAccessor\n    set saldo(valor: number) {\n        this._saldo = valor;\n    }\n\n    get saldo(): number {\n        return this._saldo;\n    }\n}\n\nlet conta = new Conta();\nconta.saldo = 100; // Sa\u00edda: \"Tentativa de alterar saldo bloqueada.\"\nconsole.log(conta.saldo); // Sa\u00edda: 0\n</code></pre> O decorator <code>bloquearAccessor</code> bloqueia a modifica\u00e7\u00e3o da propriedade <code>saldo</code>, evitando que o valor seja alterado.4. Property Decorators  Property decorators s\u00e3o aplicados a propriedades de inst\u00e2ncias. Eles podem ser usados para alterar a defini\u00e7\u00e3o de uma propriedade ou para adicionar metadados. Exemplo: </p> <p><pre><code>function somenteLeitura(target: any, propertyName: string) {\n    const descriptor: PropertyDescriptor = {\n        writable: false\n    };\n    Object.defineProperty(target, propertyName, descriptor);\n}\n\nclass Usuario {\n    @somenteLeitura\n    nome: string;\n\n    constructor(nome: string) {\n        this.nome = nome;\n    }\n}\n\nlet usuario = new Usuario(\"Nalberth\");\nusuario.nome = \"Outro Nome\"; // Erro: N\u00e3o \u00e9 poss\u00edvel atribuir a 'nome' porque \u00e9 uma propriedade somente leitura.\n</code></pre> O decorator <code>somenteLeitura</code> marca a propriedade <code>nome</code> como <code>readonly</code>, impedindo que seu valor seja alterado ap\u00f3s a inicializa\u00e7\u00e3o.5. Parameter Decorators  Parameter decorators s\u00e3o usados para adicionar metadados a par\u00e2metros de m\u00e9todos, mas diferentemente dos outros tipos de decorators, eles n\u00e3o podem alterar o comportamento do m\u00e9todo. Exemplo: </p> <p><pre><code>function logarParametro(target: any, propertyName: string, parameterIndex: number) {\n    console.log(`O par\u00e2metro no \u00edndice ${parameterIndex} do m\u00e9todo ${propertyName} foi decorado.`);\n}\n\nclass Servico {\n    metodo(@logarParametro mensagem: string) {\n        console.log(mensagem);\n    }\n}\n\nlet servico = new Servico();\nservico.metodo(\"Ol\u00e1, Decorators!\");\n</code></pre> Neste exemplo, <code>logarParametro</code> registra o \u00edndice e o nome do m\u00e9todo em que o decorator foi aplicado.</p>"},{"location":"avancado/decorators/#conclusao","title":"Conclus\u00e3o","text":"<p>Decorators s\u00e3o uma caracter\u00edstica avan\u00e7ada e poderosa do TypeScript que permitem adicionar comportamentos a classes e seus membros de maneira declarativa e reutiliz\u00e1vel. Eles s\u00e3o amplamente utilizados em frameworks como Angular para inje\u00e7\u00e3o de depend\u00eancia e outros padr\u00f5es. Entender como e quando usar decorators pode levar sua habilidade de programa\u00e7\u00e3o a um novo n\u00edvel, permitindo a cria\u00e7\u00e3o de c\u00f3digo mais modular e expressivo.</p>"},{"location":"avancado/generics/","title":"Generics","text":"<p>Generics em TypeScript s\u00e3o uma ferramenta poderosa que permite criar componentes flex\u00edveis e reutiliz\u00e1veis. Eles possibilitam que voc\u00ea defina fun\u00e7\u00f5es, classes e interfaces que n\u00e3o est\u00e3o vinculadas a um tipo espec\u00edfico, mas que funcionam com qualquer tipo de dado. Isso \u00e9 especialmente \u00fatil quando voc\u00ea deseja escrever c\u00f3digo que funcione de maneira uniforme para diferentes tipos de entrada.</p>"},{"location":"avancado/generics/#introducao-aos-generics","title":"Introdu\u00e7\u00e3o aos Generics","text":"<p>Um exemplo simples de generics \u00e9 uma fun\u00e7\u00e3o que retorna o valor que recebe como argumento. Sem generics, voc\u00ea teria que definir essa fun\u00e7\u00e3o v\u00e1rias vezes para cada tipo:</p> <p>Sem Generics:</p> <pre><code>function retornaString(valor: string): string {\n    return valor;\n}\n\nfunction retornaNumero(valor: number): number {\n    return valor;\n}\n</code></pre> <p>Com generics, voc\u00ea pode escrever uma \u00fanica fun\u00e7\u00e3o que funciona para qualquer tipo: Com Generics: </p> <p><pre><code>function retornaValor&lt;T&gt;(valor: T): T {\n    return valor;\n}\n</code></pre> Aqui, <code>T</code> \u00e9 um par\u00e2metro de tipo gen\u00e9rico . Ele atua como um placeholder para o tipo que ser\u00e1 usado quando a fun\u00e7\u00e3o for chamada.Exemplo de Uso: </p> <p><pre><code>let valorString = retornaValor&lt;string&gt;(\"Hello\");\nlet valorNumero = retornaValor&lt;number&gt;(123);\n</code></pre> No primeiro caso, <code>T</code> \u00e9 substitu\u00eddo por <code>string</code>, e no segundo, por <code>number</code>. A fun\u00e7\u00e3o funciona de maneira segura para ambos os tipos.</p>"},{"location":"avancado/generics/#generics-em-funcoes","title":"Generics em Fun\u00e7\u00f5es","text":"<p>Generics s\u00e3o frequentemente usados em fun\u00e7\u00f5es que precisam trabalhar com diferentes tipos de entrada. Vamos considerar uma fun\u00e7\u00e3o que combina dois arrays em um \u00fanico array:</p> <pre><code>function combinarArrays&lt;T&gt;(array1: T[], array2: T[]): T[] {\n    return array1.concat(array2);\n}\n\nlet numeros = combinarArrays([1, 2, 3], [4, 5, 6]);\nlet strings = combinarArrays([\"a\", \"b\", \"c\"], [\"d\", \"e\", \"f\"]);\n</code></pre> <p>Nesta fun\u00e7\u00e3o:</p> <ul> <li> <p><code>T</code> representa qualquer tipo.</p> </li> <li> <p><code>array1: T[]</code> e <code>array2: T[]</code> s\u00e3o arrays que cont\u00eam elementos do tipo <code>T</code>.</p> </li> <li> <p>O retorno \u00e9 um novo array que cont\u00e9m elementos do tipo <code>T</code>.</p> </li> </ul> <p>Isso permite combinar arrays de n\u00fameros, strings ou qualquer outro tipo.</p>"},{"location":"avancado/generics/#generics-em-interfaces","title":"Generics em Interfaces","text":"<p>Voc\u00ea pode usar generics para criar interfaces que sejam flex\u00edveis quanto aos tipos dos dados que manipulam. Isso \u00e9 \u00fatil em cen\u00e1rios onde a estrutura dos dados \u00e9 conhecida, mas o tipo exato pode variar.</p> <p><pre><code>interface Par&lt;T, U&gt; {\n    primeiro: T;\n    segundo: U;\n}\n\nlet parNumerico: Par&lt;number, number&gt; = { primeiro: 1, segundo: 2 };\nlet parMisto: Par&lt;string, number&gt; = { primeiro: \"idade\", segundo: 30 };\n</code></pre> Aqui, a interface <code>Par</code> aceita dois tipos gen\u00e9ricos, <code>T</code> e <code>U</code>. Isso permite criar pares de diferentes tipos, como <code>number</code> e <code>string</code>.</p>"},{"location":"avancado/generics/#generics-em-classes","title":"Generics em Classes","text":"<p>Generics tamb\u00e9m s\u00e3o poderosos quando usados em classes. Eles permitem que uma classe opere sobre qualquer tipo especificado, aumentando a reutiliza\u00e7\u00e3o do c\u00f3digo.</p> <p><pre><code>class Caixa&lt;T&gt; {\n    conteudo: T;\n\n    constructor(conteudo: T) {\n        this.conteudo = conteudo;\n    }\n\n    abrir(): T {\n        return this.conteudo;\n    }\n}\n\nlet caixaDeString = new Caixa&lt;string&gt;(\"Um presente\");\nlet caixaDeNumero = new Caixa&lt;number&gt;(123);\n\nconsole.log(caixaDeString.abrir()); // Sa\u00edda: \"Um presente\"\nconsole.log(caixaDeNumero.abrir()); // Sa\u00edda: 123\n</code></pre> Neste exemplo, a classe <code>Caixa</code> pode armazenar qualquer tipo de dado e retorna o mesmo tipo ao chamar o m\u00e9todo <code>abrir</code>.</p>"},{"location":"avancado/generics/#restricoes-em-generics","title":"Restri\u00e7\u00f5es em Generics","text":"<p>\u00c0s vezes, voc\u00ea pode querer que um tipo gen\u00e9rico seja limitado a um subconjunto espec\u00edfico de tipos. Isso \u00e9 feito usando constraints  (restri\u00e7\u00f5es).</p> <p><pre><code>function imprimirNome&lt;T extends { nome: string }&gt;(obj: T): void {\n    console.log(obj.nome);\n}\n\nimprimirNome({ nome: \"Nalberth\" }); // Sa\u00edda: \"Nalberth\"\n// imprimirNome({ idade: 30 }); // Erro: Propriedade 'nome' est\u00e1 ausente no tipo '{ idade: number }'.\n</code></pre> Aqui, <code>T</code> \u00e9 restrito a tipos que t\u00eam uma propriedade <code>nome</code> do tipo <code>string</code>. Isso permite que o TypeScript verifique que o objeto passado possui uma propriedade <code>nome</code>, evitando erros.</p>"},{"location":"avancado/generics/#conclusao","title":"Conclus\u00e3o","text":"<p>Generics s\u00e3o uma ferramenta essencial para escrever c\u00f3digo TypeScript flex\u00edvel e reutiliz\u00e1vel. Eles permitem que voc\u00ea crie fun\u00e7\u00f5es, classes e interfaces que funcionam de maneira uniforme para diferentes tipos, melhorando a robustez e a versatilidade do seu c\u00f3digo. Com o uso de generics, voc\u00ea pode garantir que suas abstra\u00e7\u00f5es sejam seguras e f\u00e1ceis de manter.</p>"},{"location":"ferramentas/node/","title":"TypeScript com Node.js","text":"<p>TypeScript \u00e9 uma ferramenta poderosa para o desenvolvimento com Node.js, trazendo tipagem est\u00e1tica, interfaces, e muitas outras funcionalidades que facilitam a manuten\u00e7\u00e3o e escalabilidade de projetos. Vamos explorar como configurar e utilizar TypeScript em um ambiente Node.js.</p>"},{"location":"ferramentas/node/#configurando-um-projeto-nodejs-com-typescript","title":"Configurando um Projeto Node.js com TypeScript","text":"<p>Para come\u00e7ar, crie um novo diret\u00f3rio para o seu projeto e inicialize o npm:</p> <pre><code>mkdir meu-projeto-node\ncd meu-projeto-node\nnpm init -y\n</code></pre> <p>Em seguida, instale TypeScript e as defini\u00e7\u00f5es de tipo para Node.js:</p> <p><pre><code>npm install typescript @types/node --save-dev\n</code></pre> Agora, inicialize o TypeScript criando o arquivo de configura\u00e7\u00e3o <code>tsconfig.json</code>:</p> <p><pre><code>npx tsc --init\n</code></pre> Esse comando cria um arquivo <code>tsconfig.json</code> b\u00e1sico. Aqui est\u00e1 uma configura\u00e7\u00e3o comum para projetos Node.js:</p> <p><pre><code>{\n  \"compilerOptions\": {\n    \"target\": \"ES6\",\n    \"module\": \"commonjs\",\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./src\"\n  },\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\"node_modules\"]\n}\n</code></pre> Essa configura\u00e7\u00e3o define que o TypeScript ir\u00e1 compilar o c\u00f3digo para ES6 e usar\u00e1 o sistema de m\u00f3dulos <code>commonjs</code>.</p>"},{"location":"ferramentas/node/#criando-um-servidor-http-com-typescript","title":"Criando um Servidor HTTP com TypeScript","text":"<p>Vamos criar um simples servidor HTTP usando TypeScript:</p> <ol> <li>Crie a estrutura de pastas:</li> </ol> <pre><code>mkdir src\ntouch src/server.ts\n</code></pre> <ol> <li>Adicione o seguinte c\u00f3digo ao arquivo <code>src/server.ts</code>:</li> </ol> <pre><code>import * as http from 'http';\n\nconst server = http.createServer((req, res) =&gt; {\n    res.statusCode = 200;\n    res.setHeader('Content-Type', 'text/plain');\n    res.end('Hello, TypeScript with Node.js!\\n');\n});\n\nconst PORT = 3000;\nserver.listen(PORT, () =&gt; {\n    console.log(`Servidor rodando em http://localhost:${PORT}/`);\n});\n</code></pre> <ol> <li>Para compilar e executar o servidor:</li> </ol> <pre><code>npx tsc\nnode dist/server.js\n</code></pre> <p>Este c\u00f3digo cria um servidor HTTP simples que responde com uma mensagem de texto.</p>"},{"location":"ferramentas/node/#uso-de-modulos-em-typescript","title":"Uso de Modulos em TypeScript","text":"<p>Em TypeScript, voc\u00ea pode organizar seu c\u00f3digo em m\u00f3dulos, que s\u00e3o compilados para o formato <code>commonjs</code> ou <code>ES6</code>, dependendo da sua configura\u00e7\u00e3o.Exemplo: </p> <pre><code>// src/mathUtils.ts\nexport function somar(a: number, b: number): number {\n    return a + b;\n}\n</code></pre> <p><pre><code>// src/server.ts\nimport { somar } from './mathUtils';\n\nconst resultado = somar(10, 20);\nconsole.log(`Resultado da soma: ${resultado}`);\n</code></pre> Nesse exemplo, o m\u00f3dulo <code>mathUtils</code> exporta uma fun\u00e7\u00e3o <code>somar</code>, que \u00e9 importada e usada em <code>server.ts</code>.</p>"},{"location":"ferramentas/node/#integrando-ferramentas-de-build","title":"Integrando Ferramentas de Build","text":"<p>Em projetos Node.js, voc\u00ea pode integrar TypeScript com ferramentas de build como <code>ts-node</code> para executar c\u00f3digo TypeScript diretamente sem a necessidade de compila\u00e7\u00e3o pr\u00e9via.</p> <pre><code>npm install ts-node --save-dev\n</code></pre> <p>Agora voc\u00ea pode executar seu servidor diretamente:</p> <pre><code>npx ts-node src/server.ts\n</code></pre> <p>Isso elimina a necessidade de compilar manualmente o c\u00f3digo antes de execut\u00e1-lo, o que \u00e9 \u00fatil durante o desenvolvimento.</p>"},{"location":"ferramentas/node/#conclusao","title":"Conclus\u00e3o","text":"<p>TypeScript traz muitos benef\u00edcios para o desenvolvimento com Node.js, incluindo tipagem est\u00e1tica, autocompletar aprimorado, e a detec\u00e7\u00e3o precoce de erros. Ele facilita a manuten\u00e7\u00e3o de projetos maiores e torna o c\u00f3digo mais robusto e confi\u00e1vel. Integrar TypeScript em seu ambiente Node.js \u00e9 uma escolha excelente para quem busca melhorar a qualidade e a escalabilidade de suas aplica\u00e7\u00f5es.</p>"},{"location":"ferramentas/react/","title":"TypeScript com React","text":"<p>TypeScript melhora significativamente a experi\u00eancia de desenvolvimento em projetos React, fornecendo tipagem est\u00e1tica, melhor autocompletar e detec\u00e7\u00e3o precoce de erros. Nesta se\u00e7\u00e3o, veremos como configurar e utilizar TypeScript em um projeto React.</p>"},{"location":"ferramentas/react/#configurando-um-projeto-react-com-typescript","title":"Configurando um Projeto React com TypeScript","text":"<p>Para criar um novo projeto React com suporte a TypeScript, voc\u00ea pode usar o <code>create-react-app</code> com o template TypeScript:</p> <pre><code>npx create-react-app my-app --template typescript\n</code></pre> <p>Esse comando cria um novo projeto React com todos os arquivos necess\u00e1rios j\u00e1 configurados para usar TypeScript.</p>"},{"location":"ferramentas/react/#componentes-com-tipagem","title":"Componentes com Tipagem","text":"<p>Vamos ver como podemos tipar componentes funcionais e de classe em React usando TypeScript.</p>"},{"location":"ferramentas/react/#componentes-funcionais","title":"Componentes Funcionais","text":"<p>Componentes funcionais em TypeScript s\u00e3o simples de tipar usando a interface <code>React.FC</code> (Function Component) ou explicitamente definindo os tipos de <code>props</code>.Exemplo: </p> <p><pre><code>import React from 'react';\n\ninterface SaudacaoProps {\n    nome: string;\n}\n\nconst Saudacao: React.FC&lt;SaudacaoProps&gt; = ({ nome }) =&gt; {\n    return &lt;h1&gt;Ol\u00e1, {nome}!&lt;/h1&gt;;\n};\n\nexport default Saudacao;\n</code></pre> Nesse exemplo, a interface <code>SaudacaoProps</code> define que o componente <code>Saudacao</code> espera uma prop <code>nome</code> do tipo <code>string</code>.</p>"},{"location":"ferramentas/react/#componentes-de-classe","title":"Componentes de Classe","text":"<p>Componentes de classe tamb\u00e9m podem ser tipados, especialmente em projetos mais antigos ou onde voc\u00ea prefere usar a abordagem de classes. Exemplo: </p> <p><pre><code>import React, { Component } from 'react';\n\ninterface ContadorProps {\n    valorInicial?: number;\n}\n\ninterface ContadorState {\n    valor: number;\n}\n\nclass Contador extends Component&lt;ContadorProps, ContadorState&gt; {\n    static defaultProps = {\n        valorInicial: 0,\n    };\n\n    state: ContadorState = {\n        valor: this.props.valorInicial!,\n    };\n\n    incrementar = () =&gt; {\n        this.setState({ valor: this.state.valor + 1 });\n    };\n\n    render() {\n        return (\n            &lt;div&gt;\n                &lt;p&gt;Valor: {this.state.valor}&lt;/p&gt;\n                &lt;button onClick={this.incrementar}&gt;Incrementar&lt;/button&gt;\n            &lt;/div&gt;\n        );\n    }\n}\n\nexport default Contador;\n</code></pre> Aqui, <code>ContadorProps</code> define as props e <code>ContadorState</code> define o estado do componente. A tipagem garante que voc\u00ea manipule <code>props</code> e <code>state</code> de forma segura.</p>"},{"location":"ferramentas/react/#tipagem-de-eventos","title":"Tipagem de Eventos","text":"<p>Em React, voc\u00ea frequentemente lidar\u00e1 com eventos, e TypeScript pode tip\u00e1-los para garantir que voc\u00ea manipule os eventos corretamente. Exemplo: </p> <p><pre><code>const Botao: React.FC = () =&gt; {\n    const handleClick = (event: React.MouseEvent&lt;HTMLButtonElement&gt;) =&gt; {\n        console.log('Bot\u00e3o clicado!', event.currentTarget);\n    };\n\n    return &lt;button onClick={handleClick}&gt;Clique-me!&lt;/button&gt;;\n};\n</code></pre> Aqui, <code>React.MouseEvent&lt;HTMLButtonElement&gt;</code> define que o evento \u00e9 um evento de mouse disparado por um bot\u00e3o HTML.</p>"},{"location":"ferramentas/react/#uso-de-context-api-com-typescript","title":"Uso de Context API com TypeScript","text":"<p>O React Context API tamb\u00e9m pode ser usado com TypeScript para garantir a tipagem correta dos valores compartilhados. Exemplo: </p> <p><pre><code>interface Tema {\n    background: string;\n    color: string;\n}\n\nconst TemaContext = React.createContext&lt;Tema | undefined&gt;(undefined);\n\nconst App: React.FC = () =&gt; {\n    const tema: Tema = {\n        background: 'lightblue',\n        color: 'darkblue',\n    };\n\n    return (\n        &lt;TemaContext.Provider value={tema}&gt;\n            &lt;ComponenteFilho /&gt;\n        &lt;/TemaContext.Provider&gt;\n    );\n};\n\nconst ComponenteFilho: React.FC = () =&gt; {\n    const tema = React.useContext(TemaContext);\n\n    if (!tema) {\n        return &lt;div&gt;Erro: Tema n\u00e3o encontrado!&lt;/div&gt;;\n    }\n\n    return (\n        &lt;div style={{ background: tema.background, color: tema.color }}&gt;\n            Este \u00e9 um componente com tema!\n        &lt;/div&gt;\n    );\n};\n</code></pre> Neste exemplo, <code>TemaContext</code> \u00e9 criado com uma interface <code>Tema</code> que define as propriedades esperadas no contexto.</p>"},{"location":"ferramentas/react/#conclusao","title":"Conclus\u00e3o","text":"<p>Integrar TypeScript em um projeto React oferece muitas vantagens, como tipagem est\u00e1tica, melhor suporte a ferramentas e maior seguran\u00e7a em projetos de longo prazo. Com TypeScript, voc\u00ea pode evitar muitos erros comuns e melhorar a manuten\u00e7\u00e3o do seu c\u00f3digo React.</p>"},{"location":"fundamentos/enum/","title":"Enum","text":"<p>Enums (abrevia\u00e7\u00e3o de \"enumerations\") permitem a defini\u00e7\u00e3o de um conjunto de valores nomeados que podem ser usados como constantes, proporcionando maior legibilidade e seguran\u00e7a ao c\u00f3digo. Em TypeScript, os <code>enums</code> podem ser tanto num\u00e9ricos quanto baseados em strings.</p>"},{"location":"fundamentos/enum/#enums-numericos","title":"Enums Num\u00e9ricos","text":"<p>Os <code>enums</code> num\u00e9ricos s\u00e3o o tipo mais comum. Cada valor no enum \u00e9 associado a um n\u00famero, come\u00e7ando do zero por padr\u00e3o, mas voc\u00ea pode alterar essa numera\u00e7\u00e3o.</p> <p>Exemplo:</p> <pre><code>enum Cor {\n    Vermelho, // 0\n    Verde,    // 1\n    Azul      // 2\n}\n\nlet corFavorita: Cor = Cor.Verde;\nconsole.log(corFavorita); // Sa\u00edda: 1\n</code></pre> <p>Voc\u00ea pode personalizar o valor inicial, e os valores subsequentes ser\u00e3o incrementados automaticamente. Exemplo com Valores Personalizados: </p> <pre><code>enum Cor {\n    Vermelho = 1,\n    Verde,    // 2\n    Azul      // 3\n}\n</code></pre>"},{"location":"fundamentos/enum/#enums-baseados-em-strings","title":"Enums Baseados em Strings","text":"<p>Os <code>enums</code> baseados em strings associam cada valor do enum a uma string. Eles s\u00e3o \u00fateis quando voc\u00ea quer que os valores do enum sejam mais leg\u00edveis ou quando precisa trabalhar com strings em vez de n\u00fameros.Exemplo: </p> <p><pre><code>enum Status {\n    Sucesso = \"SUCESSO\",\n    Erro = \"ERRO\",\n    Carregando = \"CARREGANDO\"\n}\n\nlet estadoAtual: Status = Status.Carregando;\nconsole.log(estadoAtual); // Sa\u00edda: \"CARREGANDO\"\n</code></pre> Os <code>enums</code> baseados em strings n\u00e3o s\u00e3o incrementados automaticamente e exigem que voc\u00ea defina explicitamente os valores para cada membro.</p>"},{"location":"fundamentos/enum/#usando-enums-em-funcoes","title":"Usando Enums em Fun\u00e7\u00f5es","text":"<p>Os <code>enums</code> podem ser usados em fun\u00e7\u00f5es para restringir os par\u00e2metros a um conjunto espec\u00edfico de valores, tornando a fun\u00e7\u00e3o mais segura e f\u00e1cil de entender.Exemplo: </p> <pre><code>function responder(status: Status): void {\n    if (status === Status.Sucesso) {\n        console.log(\"Opera\u00e7\u00e3o realizada com sucesso!\");\n    } else if (status === Status.Erro) {\n        console.log(\"Ocorreu um erro na opera\u00e7\u00e3o.\");\n    }\n}\n\nresponder(Status.Sucesso); // Sa\u00edda: \"Opera\u00e7\u00e3o realizada com sucesso!\"\n</code></pre>"},{"location":"fundamentos/enum/#conclusao","title":"Conclus\u00e3o","text":"<p>Enums s\u00e3o uma maneira poderosa de trabalhar com conjuntos fixos de valores. Eles melhoram a legibilidade do c\u00f3digo e ajudam a evitar erros comuns, como o uso de valores m\u00e1gicos. Ao entender como e quando usar enums, voc\u00ea pode tornar seu c\u00f3digo TypeScript mais expressivo e seguro.</p>"},{"location":"fundamentos/funcoes/","title":"Fun\u00e7\u00f5es","text":"<p>As fun\u00e7\u00f5es s\u00e3o blocos fundamentais de c\u00f3digo que permitem agrupar e reutilizar l\u00f3gica. Em TypeScript, as fun\u00e7\u00f5es podem ser tipadas para garantir que os valores corretos sejam passados e retornados, o que ajuda a prevenir erros comuns e torna o c\u00f3digo mais robusto.</p>"},{"location":"fundamentos/funcoes/#declaracao-de-funcoes","title":"Declara\u00e7\u00e3o de Fun\u00e7\u00f5es","text":"<p>A declara\u00e7\u00e3o de fun\u00e7\u00f5es em TypeScript \u00e9 semelhante ao JavaScript, mas com a adi\u00e7\u00e3o de tipos para par\u00e2metros e valores de retorno.</p> <p>Exemplo:</p> <pre><code>function soma(a: number, b: number): number {\n    return a + b;\n}\n</code></pre> <ul> <li> <p><code>a: number</code>  e *<code>a: number</code>*  e <code>b: number</code>  especificam que ambos os par\u00e2metros devem ser n\u00fameros.</p> </li> <li> <p><code>: number</code>  ap\u00f3s os par\u00eanteses indica que a fun\u00e7\u00e3o retorna um n\u00famero. Se voc\u00ea tentar passar um valor que n\u00e3o seja um n\u00famero para a fun\u00e7\u00e3o <code>soma</code>, TypeScript gerar\u00e1 um erro:</p> </li> </ul> <pre><code>// soma(10, \"20\"); // Erro: Argumento de tipo 'string' n\u00e3o \u00e9 atribu\u00edvel ao par\u00e2metro de tipo 'number'.\n</code></pre>"},{"location":"fundamentos/funcoes/#funcoes-anonimas","title":"Fun\u00e7\u00f5es An\u00f4nimas","text":"<p>As fun\u00e7\u00f5es an\u00f4nimas, ou fun\u00e7\u00f5es expressas, s\u00e3o fun\u00e7\u00f5es sem nome que s\u00e3o geralmente atribu\u00eddas a vari\u00e1veis. Em TypeScript, elas tamb\u00e9m podem ser tipadas. Exemplo: </p> <pre><code>let somar = function(a: number, b: number): number {\n    return a + b;\n};\n</code></pre> <p>Fun\u00e7\u00f5es an\u00f4nimas s\u00e3o \u00fateis quando voc\u00ea precisa passar uma fun\u00e7\u00e3o como argumento ou us\u00e1-la como um retorno de outra fun\u00e7\u00e3o.</p>"},{"location":"fundamentos/funcoes/#parametros-opcionais-e-valores-padrao","title":"Par\u00e2metros Opcionais e Valores Padr\u00e3o","text":"<p>Em TypeScript, voc\u00ea pode definir par\u00e2metros opcionais usando o s\u00edmbolo <code>?</code> e fornecer valores padr\u00e3o para par\u00e2metros, o que \u00e9 \u00fatil para evitar a necessidade de verificar se um par\u00e2metro foi passado.Par\u00e2metros Opcionais: </p> <pre><code>function saudar(nome: string, saudacao?: string): string {\n    return saudacao ? `${saudacao}, ${nome}!` : `Ol\u00e1, ${nome}!`;\n}\n\nconsole.log(saudar(\"Nalberth\"));            // Sa\u00edda: \"Ol\u00e1, Nalberth!\"\nconsole.log(saudar(\"Nalberth\", \"Bom dia\")); // Sa\u00edda: \"Bom dia, Nalberth!\"\n</code></pre> <ul> <li>O par\u00e2metro <code>saudacao</code> \u00e9 opcional. Se n\u00e3o for fornecido, a fun\u00e7\u00e3o usa um valor padr\u00e3o. Valores Padr\u00e3o: </li> </ul> <pre><code>function saudarComDefault(nome: string, saudacao: string = \"Ol\u00e1\"): string {\n    return `${saudacao}, ${nome}!`;\n}\n\nconsole.log(saudarComDefault(\"Nalberth\"));            // Sa\u00edda: \"Ol\u00e1, Nalberth!\"\nconsole.log(saudarComDefault(\"Nalberth\", \"Bom dia\")); // Sa\u00edda: \"Bom dia, Nalberth!\"\n</code></pre> <ul> <li>Neste exemplo, <code>saudacao</code> tem um valor padr\u00e3o de <code>\"Ol\u00e1\"</code>, que \u00e9 usado se nenhum valor for passado.</li> </ul>"},{"location":"fundamentos/funcoes/#funcoes-assincronas-asyncawait","title":"Fun\u00e7\u00f5es Ass\u00edncronas (async/await)","text":"<p>O TypeScript suporta fun\u00e7\u00f5es ass\u00edncronas usando <code>async</code> e <code>await</code>, que facilitam o trabalho com opera\u00e7\u00f5es ass\u00edncronas, como chamadas de API.Exemplo: </p> <pre><code>async function fetchData(url: string): Promise&lt;any&gt; {\n    const response = await fetch(url);\n    return response.json();\n}\n\nfetchData(\"https://api.exemplo.com/dados\")\n    .then(data =&gt; console.log(data))\n    .catch(error =&gt; console.error(error));\n</code></pre> <ul> <li> <p>A palavra-chave <code>async</code> faz com que a fun\u00e7\u00e3o retorne uma <code>Promise</code>.</p> </li> <li> <p>O <code>await</code> pausa a execu\u00e7\u00e3o da fun\u00e7\u00e3o at\u00e9 que a <code>Promise</code> seja resolvida.</p> </li> </ul>"},{"location":"fundamentos/funcoes/#funcoes-com-sobrecarga-overloading","title":"Fun\u00e7\u00f5es com Sobrecarga (Overloading)","text":"<p>O TypeScript permite definir v\u00e1rias assinaturas para uma fun\u00e7\u00e3o, permitindo que ela aceite diferentes tipos de argumentos e retorne diferentes tipos de resultados. Exemplo: </p> <pre><code>function combinar(a: string, b: string): string;\nfunction combinar(a: number, b: number): number;\nfunction combinar(a: any, b: any): any {\n    if (typeof a === \"string\" &amp;&amp; typeof b === \"string\") {\n        return a + b;\n    } else if (typeof a === \"number\" &amp;&amp; typeof b === \"number\") {\n        return a + b;\n    }\n}\n\nconsole.log(combinar(\"Ol\u00e1, \", \"Mundo!\")); // Sa\u00edda: \"Ol\u00e1, Mundo!\"\nconsole.log(combinar(10, 20));            // Sa\u00edda: 30\n</code></pre> <ul> <li>A fun\u00e7\u00e3o <code>combinar</code> pode aceitar tanto strings quanto n\u00fameros, mas cada tipo tem um comportamento espec\u00edfico.</li> </ul>"},{"location":"fundamentos/funcoes/#conclusao","title":"Conclus\u00e3o","text":"<p>As fun\u00e7\u00f5es em TypeScript s\u00e3o ferramentas poderosas que permitem criar c\u00f3digo limpo e eficiente. Com a tipagem est\u00e1tica, voc\u00ea pode prevenir muitos erros comuns e garantir que suas fun\u00e7\u00f5es sejam usadas corretamente. Entender como tipar par\u00e2metros, valores de retorno, e como trabalhar com recursos como async/await e sobrecarga de fun\u00e7\u00f5es \u00e9 essencial para escrever c\u00f3digo TypeScript robusto.</p>"},{"location":"fundamentos/readonly-const/","title":"Readonly e Const","text":"<p>Readonly e Const s\u00e3o duas maneiras de garantir a imutabilidade no TypeScript, impedindo que vari\u00e1veis ou propriedades sejam alteradas ap\u00f3s a inicializa\u00e7\u00e3o. Us\u00e1-los corretamente pode prevenir muitos erros de programa\u00e7\u00e3o e melhorar a seguran\u00e7a do c\u00f3digo.</p>"},{"location":"fundamentos/readonly-const/#readonly","title":"Readonly","text":"<p>A palavra-chave <code>readonly</code> pode ser aplicada a propriedades de classes e interfaces para garantir que essas propriedades n\u00e3o sejam modificadas ap\u00f3s serem atribu\u00eddas.</p> <p>Exemplo:</p> <p><pre><code>class Usuario {\n    readonly id: number;\n    nome: string;\n\n    constructor(id: number, nome: string) {\n        this.id = id;\n        this.nome = nome;\n    }\n}\n\nlet usuario = new Usuario(1, \"Nalberth\");\n// usuario.id = 2; // Erro: 'id' \u00e9 somente leitura e n\u00e3o pode ser alterado\n</code></pre> No exemplo acima, a propriedade <code>id</code> \u00e9 marcada como <code>readonly</code>, o que significa que ela s\u00f3 pode ser atribu\u00edda uma vez, normalmente no construtor.</p>"},{"location":"fundamentos/readonly-const/#readonly-em-interfaces","title":"Readonly em Interfaces","text":"<p>Voc\u00ea tamb\u00e9m pode usar <code>readonly</code> em interfaces para garantir que certas propriedades sejam imut\u00e1veis.Exemplo: </p> <p><pre><code>interface Produto {\n    readonly codigo: number;\n    nome: string;\n}\n\nlet produto: Produto = { codigo: 123, nome: \"Caneta\" };\n// produto.codigo = 456; // Erro: 'codigo' \u00e9 somente leitura\n</code></pre> Nesse caso, a propriedade <code>codigo</code> do objeto <code>Produto</code> n\u00e3o pode ser modificada depois de atribu\u00edda.</p>"},{"location":"fundamentos/readonly-const/#const","title":"Const","text":"<p>A palavra-chave <code>const</code> \u00e9 usada para declarar vari\u00e1veis cujos valores n\u00e3o podem ser reatribu\u00eddos ap\u00f3s a inicializa\u00e7\u00e3o. \u00c9 especialmente \u00fatil para valores que n\u00e3o devem mudar durante a execu\u00e7\u00e3o do programa.Exemplo: </p> <p><pre><code>const PI = 3.14;\n// PI = 3.1415; // Erro: N\u00e3o \u00e9 poss\u00edvel atribuir a 'PI' porque \u00e9 uma constante\n</code></pre> A constante <code>PI</code> n\u00e3o pode ser alterada depois de definida. O uso de <code>const</code> ajuda a garantir que valores cr\u00edticos n\u00e3o sejam acidentalmente modificados.</p>"},{"location":"fundamentos/readonly-const/#const-em-arrays-e-objetos","title":"Const em Arrays e Objetos","text":"<p>Embora <code>const</code> previna a reatribui\u00e7\u00e3o de vari\u00e1veis, ele n\u00e3o impede a modifica\u00e7\u00e3o dos conte\u00fados de arrays ou objetos.Exemplo: </p> <p><pre><code>const numeros = [1, 2, 3];\nnumeros.push(4); // v\u00e1lido, mas cuidado com modifica\u00e7\u00f5es\n\nconst usuario = { nome: \"Nalberth\" };\nusuario.nome = \"Carlos\"; // v\u00e1lido, mas o objeto `usuario` ainda \u00e9 o mesmo\n</code></pre> Mesmo com <code>const</code>, voc\u00ea pode alterar o conte\u00fado dos arrays e objetos. Para garantir imutabilidade completa, combine <code>const</code> com <code>readonly</code> ou t\u00e9cnicas de programa\u00e7\u00e3o imut\u00e1vel.</p>"},{"location":"fundamentos/readonly-const/#conclusao","title":"Conclus\u00e3o","text":"<p>O uso de <code>readonly</code> e <code>const</code> \u00e9 fundamental para promover a imutabilidade no c\u00f3digo TypeScript, reduzindo a probabilidade de bugs e melhorando a seguran\u00e7a do c\u00f3digo. Incorporar essas pr\u00e1ticas no seu desenvolvimento di\u00e1rio leva a um c\u00f3digo mais previs\u00edvel e confi\u00e1vel.</p>"},{"location":"fundamentos/tipos/","title":"Tipos B\u00e1sicos","text":"<p>Os tipos s\u00e3o a base da tipagem est\u00e1tica em TypeScript. Eles permitem que voc\u00ea defina quais tipos de dados s\u00e3o esperados em vari\u00e1veis, par\u00e2metros de fun\u00e7\u00e3o e valores de retorno, ajudando a prevenir erros comuns de programa\u00e7\u00e3o.</p>"},{"location":"fundamentos/tipos/#tipos-primitivos","title":"Tipos Primitivos","text":""},{"location":"fundamentos/tipos/#1-number","title":"1. Number","text":"<p>O tipo <code>number</code> \u00e9 usado para representar n\u00fameros, sejam eles inteiros ou de ponto flutuante.</p> <p>Exemplo:</p> <p><pre><code>let idade: number = 30;\nlet temperatura: number = 36.5;\n</code></pre> Voc\u00ea pode usar <code>number</code> para representar idades, contagens, temperaturas, ou qualquer outro valor num\u00e9rico.2. String O tipo <code>string</code> \u00e9 usado para representar textos. Strings em TypeScript s\u00e3o delimitadas por aspas simples (<code>'</code>), aspas duplas (<code>\"</code>), ou crases (`).Exemplo: </p> <pre><code>let nome: string = \"Nalberth\";\nlet saudacao: string = `Ol\u00e1, ${nome}!`;\n</code></pre> <p>Strings s\u00e3o ideais para armazenar nomes, mensagens, ou qualquer outro tipo de texto. 3. Boolean O tipo <code>boolean</code> s\u00f3 pode ter dois valores: <code>true</code> ou <code>false</code>. Ele \u00e9 usado em situa\u00e7\u00f5es onde voc\u00ea precisa de uma condi\u00e7\u00e3o bin\u00e1ria, como para verificar se algo \u00e9 verdadeiro ou falso.Exemplo: </p> <pre><code>let isAluno: boolean = true;\nlet aprovado: boolean = false;\n</code></pre> <p>Booleans s\u00e3o comumente usados em condicionais e loops.</p>"},{"location":"fundamentos/tipos/#tipos-complexos","title":"Tipos Complexos","text":"<ol> <li>Array Arrays em TypeScript s\u00e3o usados para armazenar uma cole\u00e7\u00e3o de valores do mesmo tipo. Voc\u00ea pode definir um array usando <code>tipo[]</code> ou <code>Array&lt;tipo&gt;</code>.Exemplo: </li> </ol> <pre><code>let numeros: number[] = [1, 2, 3, 4, 5];\nlet nomes: Array&lt;string&gt; = [\"Ana\", \"Jo\u00e3o\", \"Carlos\"];\n</code></pre> <p>Arrays s\u00e3o \u00fateis para armazenar listas de dados, como n\u00fameros ou strings. 5. Tupla  Tuplas s\u00e3o arrays de tamanho fixo onde cada elemento pode ter um tipo diferente. Elas s\u00e3o \u00fateis quando voc\u00ea sabe exatamente quantos elementos voc\u00ea ter\u00e1 e quais ser\u00e3o os tipos deles. Exemplo: </p> <p><pre><code>let pessoa: [string, number] = [\"Nalberth\", 30];\n</code></pre> Neste exemplo, a tupla <code>pessoa</code> armazena um nome e uma idade, garantindo que o primeiro elemento seja uma <code>string</code> e o segundo um <code>number</code>.6. Enum  Enums permitem definir um conjunto de valores nomeados, que s\u00e3o mapeados para valores num\u00e9ricos por padr\u00e3o. Eles s\u00e3o \u00fateis quando voc\u00ea tem um grupo fixo de valores relacionados. Exemplo: </p> <pre><code>enum Cor {\n    Vermelho,\n    Verde,\n    Azul\n}\n\nlet minhaCor: Cor = Cor.Verde;\n</code></pre> <p>Enums facilitam a leitura do c\u00f3digo ao substituir valores literais por nomes significativos.</p>"},{"location":"fundamentos/tipos/#inferencia-de-tipos","title":"Infer\u00eancia de Tipos","text":"<p>TypeScript possui um sistema de infer\u00eancia de tipos poderoso, que pode automaticamente deduzir o tipo de uma vari\u00e1vel com base em seu valor inicial. Exemplo: </p> <pre><code>let mensagem = \"Ol\u00e1, TypeScript!\"; // Inferido como string\nlet numero = 42;                   // Inferido como number\n</code></pre> <p>Embora a infer\u00eancia de tipos seja \u00fatil, \u00e9 uma boa pr\u00e1tica explicitar os tipos em partes cr\u00edticas do c\u00f3digo, especialmente em interfaces p\u00fablicas (como par\u00e2metros de fun\u00e7\u00e3o e valores de retorno).</p>"},{"location":"fundamentos/tipos/#uniao-de-tipos","title":"Uni\u00e3o de Tipos","text":"<p>Uni\u00e3o de tipos permite que uma vari\u00e1vel ou fun\u00e7\u00e3o aceite mais de um tipo. Isso \u00e9 \u00fatil em casos onde o valor pode ser de diferentes tipos. Exemplo: </p> <p><pre><code>let id: number | string;\nid = 123;        // v\u00e1lido\nid = \"ABC123\";   // tamb\u00e9m v\u00e1lido\n</code></pre> Aqui, a vari\u00e1vel <code>id</code> pode ser tanto um <code>number</code> quanto uma <code>string</code>.</p>"},{"location":"fundamentos/tipos/#conclusao","title":"Conclus\u00e3o","text":"<p>Entender e utilizar os tipos corretamente em TypeScript \u00e9 fundamental para aproveitar ao m\u00e1ximo a seguran\u00e7a oferecida pela tipagem est\u00e1tica. Ao especificar tipos, voc\u00ea cria c\u00f3digo mais robusto e f\u00e1cil de entender, reduzindo a probabilidade de erros.</p>"},{"location":"fundamentos/union-types/","title":"Union Types","text":"<p>Union Types em TypeScript permitem que uma vari\u00e1vel, par\u00e2metro ou fun\u00e7\u00e3o aceite mais de um tipo de dado. Isso \u00e9 especialmente \u00fatil quando voc\u00ea precisa de flexibilidade, mas ainda quer manter a seguran\u00e7a de tipos.</p>"},{"location":"fundamentos/union-types/#definindo-union-types","title":"Definindo Union Types","text":"<p>Para definir um union type, voc\u00ea usa o operador <code>|</code>, que representa \"ou\". Isso permite que uma vari\u00e1vel possa ser de um tipo ou outro.</p> <p>Exemplo:</p> <p><pre><code>let id: number | string;\n\nid = 123;       // v\u00e1lido\nid = \"ABC123\";  // v\u00e1lido\n// id = true;   // Erro: 'boolean' n\u00e3o \u00e9 atribu\u00edvel a 'number | string'\n</code></pre> Neste exemplo, a vari\u00e1vel <code>id</code> pode ser um n\u00famero ou uma string, mas n\u00e3o pode ser um booleano.</p>"},{"location":"fundamentos/union-types/#usando-union-types-em-funcoes","title":"Usando Union Types em Fun\u00e7\u00f5es","text":"<p>Fun\u00e7\u00f5es podem utilizar union types para aceitar diferentes tipos de par\u00e2metros, mas voc\u00ea precisa lidar com cada caso dentro da fun\u00e7\u00e3o. Exemplo: </p> <p><pre><code>function imprimirId(id: number | string): void {\n    if (typeof id === \"number\") {\n        console.log(`ID num\u00e9rico: ${id}`);\n    } else {\n        console.log(`ID string: ${id}`);\n    }\n}\n\nimprimirId(123);       // Sa\u00edda: \"ID num\u00e9rico: 123\"\nimprimirId(\"ABC123\");  // Sa\u00edda: \"ID string: ABC123\"\n</code></pre> Neste exemplo, a fun\u00e7\u00e3o <code>imprimirId</code> aceita um n\u00famero ou uma string e lida com cada caso separadamente.</p>"},{"location":"fundamentos/union-types/#union-types-em-arrays","title":"Union Types em Arrays","text":"<p>Voc\u00ea tamb\u00e9m pode usar union types em arrays, permitindo que o array contenha elementos de diferentes tipos. Exemplo: </p> <p><pre><code>let valores: (number | string)[] = [1, \"dois\", 3, \"quatro\"];\n\nvalores.push(5);      // v\u00e1lido\nvalores.push(\"seis\"); // v\u00e1lido\n// valores.push(true); // Erro: 'boolean' n\u00e3o \u00e9 atribu\u00edvel a 'number | string'\n</code></pre> Neste caso, <code>valores</code> \u00e9 um array que pode conter n\u00fameros e strings, mas n\u00e3o outros tipos.</p>"},{"location":"fundamentos/union-types/#conclusao","title":"Conclus\u00e3o","text":"<p>Union types fornecem flexibilidade em situa\u00e7\u00f5es onde uma vari\u00e1vel ou fun\u00e7\u00e3o precisa trabalhar com m\u00faltiplos tipos. No entanto, \u00e9 importante us\u00e1-los com cuidado para evitar complexidade excessiva no c\u00f3digo. Eles s\u00e3o mais adequados para cen\u00e1rios onde a flexibilidade \u00e9 necess\u00e1ria, mas a clareza e seguran\u00e7a de tipos ainda s\u00e3o prioridades.</p>"}]}